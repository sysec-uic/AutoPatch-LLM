# Technical Spike: OSS-Fuzz Integration <!-- omit in toc -->

- [Spike: OSS-Fuzz Integration](#spike-spike-name)
- [Goal](#goal)
- [Method](#method)
- [Evidence](#evidence)
- [Conclusions](#conclusions)
- [Next Steps](#next-steps)

## Spike: OSS-Fuzz Integration

Conducted by: Lily Leith, <lleit@uic.edu>
Backlog Work Item: #128
Sprint: 4/28/25

## Goal

After conducting this spike, we should know the following about the oss-fuzz procedure:

- The encoding used for the crash inputs.
- Any logging of the crash signal.
- The context provided by standard error and the stack trace.
- How oss-fuzz builds the fuzzers from the local checkout of the buggy library.
- Whether all projects on oss-fuzz have a public seed corpus directory.
- Other topic to investigate more: what the patches look like, how easily are the fixes to interpret within a smaller contextual scope.

That information will help answer the following questions:

1. How would crash inputs need to be manipulated to form CrashDetail objects?
2. What parts of the standard error and stack trace are redundant given the CPG component? Are there any parts included in the standard error and stack trace that could be parsed for utilization in LLM-dispatch context?
3. What is the best method for invoking buggy programs from oss-fuzz within the existing fuzzing service?

## Method

Explore oss-fuzz tools by building fuzzers of buggy libraries/codebases, run the fuzzers, examine the inputs, and log the results.

## Evidence

- The encoding used for the crash inputs.

My findings indicate that the crash inputs are encoded differently from project to project, and are most likely encoded in the encoding that the source code will expect. For example, openbabel crash inputs are in ascii, whereas libxml2 inputs are encoded with Windows-1254.

- Any logging of the crash signal.

libFuzzer outputs don't give any indiation of the numerical exit signal/code beyond what can be inferred by the information given in the stack trace. This might be different when using afl as the engine, but most bug reports cite libFuzzer.

- The context provided by standard error and the stack trace.

As of right now, the CPG scan result is describing an isolated line at which a vulnerability is sourced. The crashes in oss-fuzz projects involve many files interacting, so that the crash could occur in one file, while the patch updates code in other files. If the files were linked and represented in the same CPG, then the information in the stack trace would be redundant. Right now, the stack trace is very helpful for tracing execution that lead to the crash. However, following file to file execution has to be done manually, and doesn't help contextualize the issue very much.

- How oss-fuzz builds the fuzzers from the local checkout of the buggy library.

Not sure on the sourcing local part
It's possible to build the projects without oss-fuzz but each one is different, oss-fuzz gives an opportunity for some level of automation. How would Dockerfiles fit into our current application?

- Whether all projects on oss-fuzz have a public seed corpus directory.

No, they do not. But if you don't specify an input seed directory, the fuzzer will start a new corpus.

- Other topic to investigate more: what the patches look like, how easily are the fixes to interpret within a smaller contextual scope.

## Conclusions

What was the answer to the question(s) outlined at the start of the spike? Capture what was learned that will inform future work.

## Next Steps

What work is expected as an outcome of the learning within this spike. Was there work that was blocked or dependent on the learning within this spike?
