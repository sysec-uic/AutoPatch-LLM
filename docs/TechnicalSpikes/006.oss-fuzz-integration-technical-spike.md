# Technical Spike: OSS-Fuzz Integration <!-- omit in toc -->

- [Spike: OSS-Fuzz Integration](#spike-spike-name)
- [Goal](#goal)
- [Method](#method)
- [Evidence](#evidence)
- [Conclusions](#conclusions)
- [Next Steps](#next-steps)

## Spike: OSS-Fuzz Integration

Conducted by: Lily Leith, <lleit@uic.edu>
Backlog Work Item: #128
Sprint: 4/28/25

## Goal

After conducting this spike, we should know the following about the oss-fuzz procedure:

- The encoding used for the crash inputs.
- Any logging of the crash signal.
- The context provided by standard error and the stack trace.
- How oss-fuzz builds the fuzzers from the local checkout of the buggy library.
- Whether all projects on oss-fuzz have a public seed corpus directory.
- Other topic to investigate more: what the patches look like, how easily are the fixes to interpret within a smaller contextual scope.

That information will help answer the following questions:

1. How would crash inputs need to be manipulated to form CrashDetail objects?
2. What parts of the standard error and stack trace are redundant given the CPG component? Are there any parts included in the standard error and stack trace that could be parsed for utilization in LLM-dispatch context?
3. What is the best method for invoking buggy programs from oss-fuzz within the existing fuzzing service?

## Method

Explore oss-fuzz tools by building fuzzers of buggy libraries/codebases, run the fuzzers, examine the inputs, and log the results.

## Evidence

- The encoding used for the crash inputs.

My findings indicate that the crash inputs are encoded differently from project to project, and are most likely encoded in the encoding that the source code will expect. For example, openbabel crash inputs are in ascii, whereas libxml2 inputs are encoded with Windows-1254.

- Any logging of the crash signal.

libFuzzer outputs don't give any indiation of the numerical exit signal/code beyond what can be inferred by the information given in the stack trace. This might be different when using afl as the engine, but most bug reports cite libFuzzer.

- The context provided by standard error and the stack trace.

As of right now, the CPG scan result is describing an isolated line at which a vulnerability is sourced. The crashes in oss-fuzz projects involve many files interacting, so that the crash could occur in one file, while the patch updates code in other files. If the files were linked and represented in the same CPG, then the information in the stack trace would be redundant. Right now, the stack trace is very helpful for tracing execution that lead to the crash. However, following file to file execution has to be done manually, and doesn't help contextualize the issue very much.

- How oss-fuzz builds the fuzzers from the local checkout of the buggy library.

oss-fuzz uses the local checkout as the source working directory for the build, so that all executables are compiled into the local tree.

- Whether all projects on oss-fuzz have a public seed corpus directory.

No, they do not. But if you don't specify an input seed directory, the fuzzer will start a new corpus, and as it fuzzes it will add inputs to the corpus that
bring execution to new paths.

- Other topic to investigate more: what the patches look like, how easily are the fixes to interpret within a smaller contextual scope.

## Conclusions

We can summarize with the answers to the following questions:

1. How would crash inputs need to be manipulated to form CrashDetail objects?

    To form the crash inputs into CrashDetail objects, we would first need to discover the encoding used for the input. This can be achieved (to some level of certainty) with a python library such as chardet.

2. What parts of the standard error and stack trace are redundant given the CPG component? Are there any parts included in the standard error and stack trace that could be parsed for utilization in LLM-dispatch context?

    With the current code inputs, the CPG information is succinct in identifying the location of the crash by isolating vulnerable functions. However, we cannot say at this point how well CPG information can summize vulnerabilities in larger programs. For now, the stack trace is useful but cumbersome to identify execution flow and determine which files are necessary to provide context to the LLM. However, this is manual work that would ideally be replaced by CPG automation.

3. What is the best method for invoking buggy programs from oss-fuzz within the existing fuzzing service?

    oss-fuzz relies on Dockerfiles for the building of the programs. The most feasible option might be to manually build the projects using the Dockerfile, then manually run the fuzz targets within our existing fuzzing service.

## Next Steps

Integrating oss-fuzz into the automated flow of the existing application will take significant work. Some parts of the integration might remain manual, such as the building of the projects since they rely on Dockerfiles. The next steps are to investigate how well these larger projects are representated as CPGs, so we can consider the amount of additional context we might need to bring from the stack trace if the CPG is not capable of representing such large programs.
