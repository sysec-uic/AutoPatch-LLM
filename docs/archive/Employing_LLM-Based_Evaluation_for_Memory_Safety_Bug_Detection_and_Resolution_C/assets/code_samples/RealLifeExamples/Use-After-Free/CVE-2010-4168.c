https://github.com/OpenTTD/OpenTTD/commit/673b371#diff-31dd9b11e3c119e4e65cf2b3dc0ab704b71d41728d0e1ad8ecc109cfee907ed7R454

/* $Id$ */

/*
 * This file is part of OpenTTD.
 * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
 */

/** @file network_server.cpp Server part of the network protocol. */

#ifdef ENABLE_NETWORK

#include "../stdafx.h"
#include "../debug.h"
#include "../strings_func.h"
#include "../date_func.h"
#include "network_admin.h"
#include "network_server.h"
#include "network_udp.h"
#include "network.h"
#include "network_base.h"
#include "../console_func.h"
#include "../company_base.h"
#include "../command_func.h"
#include "../saveload/saveload.h"
#include "../station_base.h"
#include "../genworld.h"
#include "../fileio_func.h"
#include "../company_func.h"
#include "../company_gui.h"
#include "../window_func.h"
#include "../roadveh.h"
#include "../order_backup.h"
#include "../core/pool_func.hpp"
#include "../rev.h"

#include "table/strings.h"

/* This file handles all the server-commands */

DECLARE_POSTFIX_INCREMENT(ClientID)
/** The identifier counter for new clients (is never decreased) */
static ClientID _network_client_id = CLIENT_ID_FIRST;

/** Make very sure the preconditions given in network_type.h are actually followed */
assert_compile(MAX_CLIENT_SLOTS > MAX_CLIENTS);
assert_compile(NetworkClientSocketPool::MAX_SIZE == MAX_CLIENT_SLOTS);

NetworkClientSocketPool _networkclientsocket_pool("NetworkClientSocket");
INSTANTIATE_POOL_METHODS(NetworkClientSocket)

/** Instantiate the listen sockets. */
template SocketList TCPListenHandler<ServerNetworkGameSocketHandler, PACKET_SERVER_FULL, PACKET_SERVER_BANNED>::sockets;

/**
 * Create a new socket for the server side of the game connection.
 * @param s The socket to connect with.
 */
ServerNetworkGameSocketHandler::ServerNetworkGameSocketHandler(SOCKET s) : NetworkGameSocketHandler(s)
{
	this->status = STATUS_INACTIVE;
	this->client_id = _network_client_id++;
	NetworkClientInfo *ci = new NetworkClientInfo(this->client_id);
	this->SetInfo(ci);
	ci->client_playas = COMPANY_INACTIVE_CLIENT;
	ci->join_date = _date;
}

/**
 * Clear everything related to this client.
 */
ServerNetworkGameSocketHandler::~ServerNetworkGameSocketHandler()
{
	if (_redirect_console_to_client == this->client_id) _redirect_console_to_client = INVALID_CLIENT_ID;
	OrderBackup::ResetUser(this->client_id);
}

NetworkRecvStatus ServerNetworkGameSocketHandler::CloseConnection(NetworkRecvStatus status)
{
	assert(status != NETWORK_RECV_STATUS_OKAY);
	/*
	 * Sending a message just before leaving the game calls cs->Send_Packets.
	 * This might invoke this function, which means that when we close the
	 * connection after cs->Send_Packets we will close an already closed
	 * connection. This handles that case gracefully without having to make
	 * that code any more complex or more aware of the validity of the socket.
	 */
	if (this->sock == INVALID_SOCKET) return status;

	if (status != NETWORK_RECV_STATUS_CONN_LOST && !this->HasClientQuit() && this->status >= STATUS_AUTHORIZED) {
		/* We did not receive a leave message from this client... */
		char client_name[NETWORK_CLIENT_NAME_LENGTH];
		NetworkClientSocket *new_cs;

		this->GetClientName(client_name, sizeof(client_name));

		NetworkTextMessage(NETWORK_ACTION_LEAVE, CC_DEFAULT, false, client_name, NULL, STR_NETWORK_ERROR_CLIENT_CONNECTION_LOST);

		/* Inform other clients of this... strange leaving ;) */
		FOR_ALL_CLIENT_SOCKETS(new_cs) {
			if (new_cs->status > STATUS_AUTHORIZED && this != new_cs) {
				new_cs->SendErrorQuit(this->client_id, NETWORK_ERROR_CONNECTION_LOST);
			}
		}
	}

	DEBUG(net, 1, "Closed client connection %d", this->client_id);

	/* We just lost one client :( */
	if (this->status >= STATUS_AUTHORIZED) _network_game_info.clients_on--;
	extern byte _network_clients_connected;
	_network_clients_connected--;

	SetWindowDirty(WC_CLIENT_LIST, 0);

	this->Send_Packets(true);

	delete this->GetInfo();
	delete this;

	return status;
}

/**
 * Whether an connection is allowed or not at this moment.
 * @return true if the connection is allowed.
 */
/* static */ bool ServerNetworkGameSocketHandler::AllowConnection()
{
	extern byte _network_clients_connected;
	return _network_clients_connected < MAX_CLIENTS && _network_game_info.clients_on < _settings_client.network.max_clients;
}

/** Send the packets for the server sockets. */
/* static */ void ServerNetworkGameSocketHandler::Send()
{
	NetworkClientSocket *cs;
	FOR_ALL_CLIENT_SOCKETS(cs) {
		if (cs->writable) {
			cs->Send_Packets();
			if (cs->status == STATUS_MAP) {

				/* This client is in the middle of a map-send, call the function for that */
				cs->SendMap();
			}
		}
	}
}  and NetworkRecvStatus ServerNetworkGameSocketHandler::SendMap()
{
	static FILE *file_pointer = NULL;
	static uint sent_packets; // How many packets we did send succecfully last time

	if (this->status < STATUS_AUTHORIZED) {
		/* Illegal call, return error and ignore the packet */
		return this->SendError(NETWORK_ERROR_NOT_AUTHORIZED);
	}

	if (this->status == STATUS_AUTHORIZED) {
		const char *filename = "network_server.tmp";
		Packet *p;

		/* Make a dump of the current game */
		if (SaveOrLoad(filename, SL_SAVE, AUTOSAVE_DIR) != SL_OK) usererror("network savedump failed");

		if (file_pointer != NULL) fclose(file_pointer);

		file_pointer = FioFOpenFile(filename, "rb", AUTOSAVE_DIR);
		if (file_pointer == NULL) usererror("network savedump failed - could not open just saved dump");

		fseek(file_pointer, 0, SEEK_END);
		if (ftell(file_pointer) == 0) usererror("network savedump failed - zero sized savegame?");

		/* Now send the _frame_counter and how many packets are coming */
		p = new Packet(PACKET_SERVER_MAP_BEGIN);
		p->Send_uint32(_frame_counter);
		p->Send_uint32(ftell(file_pointer));
		this->Send_Packet(p);

		fseek(file_pointer, 0, SEEK_SET);

		sent_packets = 4; // We start with trying 4 packets

		NetworkSyncCommandQueue(this);
		this->status = STATUS_MAP;
		/* Mark the start of download */
		this->last_frame = _frame_counter;
		this->last_frame_server = _frame_counter;
	}

	if (this->status == STATUS_MAP) {
		uint i;
		int res;
		for (i = 0; i < sent_packets; i++) {
			Packet *p = new Packet(PACKET_SERVER_MAP_DATA);
			res = (int)fread(p->buffer + p->size, 1, SEND_MTU - p->size, file_pointer);

			if (ferror(file_pointer)) usererror("Error reading temporary network savegame!");

			p->size += res;
			this->Send_Packet(p);
			if (feof(file_pointer)) {
				/* Done reading! */
				Packet *p = new Packet(PACKET_SERVER_MAP_DONE);
				this->Send_Packet(p);

				/* Set the status to DONE_MAP, no we will wait for the client
				 *  to send it is ready (maybe that happens like never ;)) */
				this->status = STATUS_DONE_MAP;
				fclose(file_pointer);
				file_pointer = NULL;

				NetworkClientSocket *new_cs;
				bool new_map_client = false;
				/* Check if there is a client waiting for receiving the map
				 *  and start sending him the map */
				FOR_ALL_CLIENT_SOCKETS(new_cs) {
					if (new_cs->status == STATUS_MAP_WAIT) {
						/* Check if we already have a new client to send the map to */
						if (!new_map_client) {
							/* If not, this client will get the map */
							new_cs->status = STATUS_AUTHORIZED;
							new_map_client = true;
							new_cs->SendMap();
						} else {
							/* Else, send the other clients how many clients are in front of them */
							new_cs->SendWait();
						}
					}
				}

				/* There is no more data, so break the for */
				break;
			}
		}

		/* Send all packets (forced) and check if we have send it all */
		this->Send_Packets();
		if (this->IsPacketQueueEmpty()) {

			/* All are sent, increase the sent_packets */
			sent_packets *= 2;
		} else {
			/* Not everything is sent, decrease the sent_packets */
			if (sent_packets > 1) sent_packets /= 2;
		}
	}
	return NETWORK_RECV_STATUS_OKAY;
} 
