//https://issues.chromium.org/issues/332382766
107   /* Calculate storage sizes given the chroma subsampling */
 108   w = align_image_dimension(d_w, xcs, size_align);
 109   h = align_image_dimension(d_h, ycs, size_align);
 110 
 111   s = (fmt & AOM_IMG_FMT_PLANAR) ? w : bps * w / bit_depth;   <==== s and w are 32-bit integer variable
 112   s = (s + 2 * border + stride_align - 1) & ~(stride_align - 1);
 113   stride_in_bytes = s * bit_depth / 8;    <==== Integer overflow occurred, causing stride_in_bytes to become a smaller value.
 114 
 115   /* Allocate the new image */
 116   if (!img) {
 117     img = (aom_image_t *)calloc(1, sizeof(aom_image_t));
 118 
 119     if (!img) goto fail;
 120 
 121     img->self_allocd = 1;
 122   }
 123 
 124   img->img_data = img_data;
 125 
 126   if (!img_data) {
 127     const uint64_t alloc_size =
 128         (fmt & AOM_IMG_FMT_PLANAR)
 129             ? (uint64_t)(h + 2 * border) * stride_in_bytes * bps / bit_depth
 130             : (uint64_t)(h + 2 * border) * stride_in_bytes;
 131 
 132     if (alloc_size != (size_t)alloc_size) goto fail;
 133 
 134     if (alloc_cb) {
 135       const size_t padded_alloc_size = (size_t)alloc_size + buf_align - 1;
 136       img->img_data = (uint8_t *)alloc_cb(cb_priv, padded_alloc_size);
 137       if (img->img_data) {
 138         img->img_data = (uint8_t *)aom_align_addr(img->img_data, buf_align);
 139       }
 140       img->img_data_owner = 0;
 141     } else {
 142       img->img_data = (uint8_t *)aom_memalign(buf_align, (size_t)alloc_size);     <==== Object allocation
 143       img->img_data_owner = 1;
 144     }
 145     img->sz = (size_t)alloc_size;
 146   }
 147 
 148   if (!img->img_data) goto fail;
 149 
 150   img->fmt = fmt;
 151   img->bit_depth = bit_depth;
 152   // aligned width and aligned height
 153   img->w = w; 
 154   img->h = h;
 155   img->x_chroma_shift = xcs;
 156   img->y_chroma_shift = ycs;
 157   img->bps = bps;
